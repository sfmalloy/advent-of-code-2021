**NOTE:** This repository is now archived. Please use [my solutions monorepo](https://github.com/sfmalloy/advent-of-code) to find any future changes.
___

# Advent of Code 2021!!

Past couple years I've attempted have been in Python. This year I'm attempting to do all 25 days each in a different language. The `extras` branch has some extra bonus solutions for fun in other langauges (some duplicate langauges).

| Day | Language | Description |
------|----------|-------------|
|1|x86 Assembly|Did it in a higher level language first and then translated by hand into x86. Fun problem and not too bad in assembly!|
|2|Haskell|Spent way too long trying to parse input. Once I figured that out it was pretty smooth sailing.|
|3|Go|Interesting langauge. Like some sort of C/Python hybrid or something. Solution ended up being kind of fast-ish. Arrays are weird to work with.|
|4|Java|Java streams and Scanner made input parsing not terrible. The rest of the problem was fine because of that.|
|5|Ruby|I like Ruby. Similar to Python so it's easy to get a hang of quick and write some quick code. Initial solution is not the best but it works! Also hashes are wonderful and super easy to use in Ruby, 10/10|
|6|C|I like C, no complaints really. This problem was good for C because there weren't complicated data structures to deal with. At first I ended up trying to simulate using a linked list for part 1, but it didn't work for part 2 because it was too slow. Then I realized I only need the counts and nothing else, making my part 1 solution obsolete. I kept it though in the `extras` directory for fun.|
|7|Kotlin|Kotlin is really nice. Compiles to Java JVM bytecode but has a more concise syntax. Overall great language, and fairly nice problem to do in Kotlin!|
|8|Javascript|This was honestly a really good problem for Javascript. Being able to pass comparison functions made this solution *mostly* clean.|
|9|Julia|An alright language. Some weird quirks but overall an alright experience. Having set unions built in came in very handy|
|10|Swift|Not a huge fan of Swift for some reason. The syntax is overall fine in the end, but the compiler error messages weren't always the best. Mostly, Strings are not fun to deal with in this language. There's a lot of setup to use them which makes it somewhat tedious. For the problem itself, tried to solve using recursion at first, ended up using "stacks" (arrays used as stacks). That part wasn't too bad after getting used to using `!` when needed.|
|11|Perl|Perl is an interesting language. Everything is lists or scalars and it's interesting to convert between the two. Not having to convert a read in string to an integer to do arithmetic on it was interesting. Could do some interesting visualizations fairly easily in this language if desired.|
|12|Common Lisp|Done purely functional, no setq or anything like that. It was *very* hard at first but eventually dropped the notion that this needs to be clean/efficient code and ended up with this solution. It was very satisfying in the end and I'm glad I solved this in Lisp. Path finding problems fit recursion very nicely too, which helps (a lot).|
|13|Rust|Good language. Fast and fun to use, and has lots of neat std lib stuff I want to explore eventually. Fun fact I started this problem in Typescript and realized Sets don't work good with custom classes, so I switched to Rust which has #derive for basic implementations of methods for comparison and hashing.|
|14|Typescript|Pretty much just Javascript with types. I really enjoyed using this language, has a good Map class which was 1000% needed for this day. I tired Lua at first and it was not fun so not sure if I'll actually use Lua for a problem or not.|
|15|C++|C++ fast and has a priority queue built in which came in *very* handy today. Overall nice experience, and I finally implemented Dijkstra's for I think the first time during this so that's fun.|
|16|C#|C# very good. Like better Java made by Microsoft. Super easy to implement the Visitor design pattern in for making a mini-compiler|
|17|R|R isn't great on its own...imported the `sets` library so I could have tuples which helped a lot in this problem|
|18|Python|One of my, if not my most favorite language. So many useful built-in libraries, and fun stuff you can do with non-static types and whatnot (if you look I used `isinstance` a lot haha). This problem was perfect for Python with the way lists work, and worked very naturally recursively.|
|19|CoffeeScript|JavaScript without curley braces and slightly more strict formatting. Not bad. Solution used a lot of vector operations which I wished I could've used a different language for but it got the job done. (Albeit slowly)|
|20|PHP|This problem was a doozy honestly, but honestly...PHP actually made it easier with how arrays are essentially just dictionaries.|
|21|Lua|Went back to Lua, was able to do some dynamic programming stuff. Scoping is still somewhat confusing sometimes but glad I was able to solve a day in Lua in the end (after giving up on it Day 14).|
|22|Scala|I really liked Scala for this problem. Runs *decently* fast for a JVM language. Problem was fun overall, involved some fun recursion.|
|23|
|24|
|25|
